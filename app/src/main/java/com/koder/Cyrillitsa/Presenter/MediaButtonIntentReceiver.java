package com.koder.Cyrillitsa.Presenter;

/**
 * Created by Viktor Galkin/koder/on 01.02.2020
 */

// строки класса   начинаются со слова “import”. Это инструкции, которые дают указания включить другие пакеты в нашем проекте.
// Этот инструмент даёт нам возможность пользоваться тем кодом,который уже за нас написан другими программистами

// стандартный класс Приемник_Широковещательных_Сообщений

//намерения можно использовать для отправки сообщений, предназначенные не какому-то отдельному приложению, объекту или компоненту,
// а всем. И любая программа, оборудованная специальным приёмником,
// может поймать это сообщение и предпринять свои шаги на основе полученной информации.
//
//Сообщения может создавать сама система, а также ваша программа и чужие программы.
//
//Передача сообщений весьма проста в реализации. В вашем приложении необходимо создать сообщение, которое вы хотите передать.
// Установите при необходимости поля action, data и category (действие, данные и категорию) вашего сообщения и путь,
// который позволяет приёмникам широковещательных сообщений точно определять "своё" сообщение.
// В этом сообщении строка действия ACTION должна быть уникальной, чтобы идентифицировать передаваемое действие.
// В таких случаях создают строку-идентификатор действия по правилам именования пакетов Java.
// Например, для обнаружения кота в большом здании:
//
//public static final String NEW_CAT_DETECTED = "ru.alexanderklimov.action.NEW_CAT";

//Далее вы создаёте объект Intent, загружаете в него нужную информацию и вызываете метод sendBroadcast(),
// передав ему в качестве параметра созданный объект Intent.
// Дополнительные данные можно использовать в extras как необязательные параметры.

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.util.Log;
import android.view.KeyEvent;

import com.koder.Cyrillitsa.MainActivity;


//открытый класс MediaButtonIntentReceiver(Приемник_Сообщений_Интента_Медиа_Кнопок) расширяющий стандартный класс
//BroadcastReceiver(Приемник_Широковещательных_Сообщений)

//класс MediaButtonIntentReceiver(Приемник_Сообщений_Интента_Медиа_Кнопок) состоит из:


//конструктора класса Приемник_Сообщений_Интента_Медиа_Кнопок

//открытый метод  типа void Получить(контекст,интент)

//значение Интент_кнопки = интенту.Получающий_действие()


//Проверка : если не существует интент.АКТИВНОЙ_МЕДИА_КНОПКИ.с_совпадением_адреса(интент_Кнопке)


//то выход из метода


//Ключ_События= интент.Извлекаем_объект_из_интент_методом getParcelableExtra() (интент.КЛЮЧ_СОБЫТИЯ)


//Чтобы нам передать объект через Intent, нам надо реализовать в нем интерфейс Parcelable. В этом случае Intent без
// проблем запакует, передаст и распакует наш объект. И я так подозреваю, что делает он это с помощью Parcel.
// Т.е. в реализации интерфейса Parcelable мы полностью описываем алгоритм упаковки и распаковки объекта, а Parcel
// эти алгоритмы потом использует. Т.к. сам он не может знать, как правильно распаковать и создать передаваемый объект.

//отладочное сообщение Log.i("Key", event.getKeyCode() + " pressed");


//действие = событие.Получающее_действие()


//если действие равно Ключу_События.ДЕЙСТВИЕ_ВНИЗ


//и если Ключ_События == КОД_КЛЮЧ_МЕДИА_ПАУЗЫ или Ключ_События == КОД_КЛЮЧ_МЕДИА_ПАУЗЫ_ПРОИГРЫВАНИЯ  или Ключ_События == 79)


//то выполняем в Главной_Активности.Переключение_Видео()

//иначе
//  поскольку MainActivity не запущена,ловим исключение


public class MediaButtonIntentReceiver extends BroadcastReceiver {

    //конструктор класса Приемник_Сообщений_Интента_Медиа_Кнопок
    public MediaButtonIntentReceiver()
    {
        //конструктор стандартного суперкласса Приемник_Широковещательных_Сообщений
        super();
    }

    //открытый метод  типа void Получить_данные_от_главной_активности(контекст,интент)

    //Слово @Override указывает нам то, что метод, который следует далее, переопределён.
    @Override

    public void onReceive(Context context, Intent intent)
    {
        //значение Интент_кнопки = интенту.Получающий_действие()
        String intentButton = intent.getAction();

        //Проверка : если не существует интент.АКТИВНОЙ_МЕДИА_КНОПКИ.с_совпадением_адреса(интент_Кнопке)

        //метод equals() класса Object используется для сравнения объектов
//метод equals() сравнивает ссылки на адреса в памяти ,которые хранят переменные и возвращает
//true только в том случае,если адреса совпадают(т.е.переменные ссылаются на один и тот же объект)

        if (!Intent.ACTION_MEDIA_BUTTON.equals(intentButton))
        {
            //то выход из метода
            return;
        }

// активность  MediaButtonIntentRecever должна принять данные события  event  от главной  активности  :

        //

        //методом getParcelableExtra()  извлекаем объект из Intent.

        //Ключ_События= интент.Извлекаем_объект_из_интент(интент.КЛЮЧ_СОБЫТИЯ)


        //Чтобы нам передать объект через Intent, нам надо реализовать в нем интерфейс Parcelable. В этом случае Intent без
        // проблем запакует, передаст и распакует наш объект. И я так подозреваю, что делает он это с помощью Parcel.
        // Т.е. в реализации интерфейса Parcelable мы полностью описываем алгоритм упаковки и распаковки объекта, а Parcel
        // эти алгоритмы потом использует. Т.к. сам он не может знать, как правильно распаковать и создать передаваемый объект.
        //
        KeyEvent event = (KeyEvent) intent.getParcelableExtra(Intent.EXTRA_KEY_EVENT);

        Log.i("Key", event.getKeyCode() + " pressed");


        //действие = событие.Получающее_действие()
        int action = event.getAction();

        //если действие равно Ключу_События.ДЕЙСТВИЕ_ВНИЗ

        if (action == KeyEvent.ACTION_DOWN)
        {
            //если Ключ_События == КОД_КЛЮЧ_МЕДИА_ПАУЗЫ или Ключ_События == КОД_КЛЮЧ_МЕДИА_ПАУЗЫ_ПРОИГРЫВАНИЯ  или Ключ_События == 79)

            if (event.getKeyCode() == KeyEvent.KEYCODE_MEDIA_PAUSE || event.getKeyCode() == KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE
                    || event.getKeyCode() == 79) {
                //то выполняем в Главной_Активности.Переключение_Видео()
                try {
                    MainActivity.toggleVideo();
                }
                //иначе
                //  поскольку MainActivity не запущена,ловим ошибку,
                catch (Exception e)
                {
                    // MainActivity не запущена
                    e.printStackTrace();
                }
            }
        }
    }

}


