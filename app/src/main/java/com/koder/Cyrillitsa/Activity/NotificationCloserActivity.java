package com.koder.Cyrillitsa.Activity;

/**
 * Created by Viktor Galkin/koder/on 01.02.2020
 */

// строки класса   начинаются со слова “import”. Это инструкции, которые дают указания включить другие пакеты в нашем проекте.
// Этот инструмент даёт нам возможность пользоваться тем кодом,который уже за нас написан другими программистами

import android.app.Activity;
import android.app.NotificationManager;
import android.app.PendingIntent;
import android.content.Context;
import android.content.Intent;
import android.os.Bundle;
import android.util.Log;

import com.koder.Cyrillitsa.MainActivity;

//открытый класс NotificationCloserActivity(Активность_Закрывающая_Уведомления) расширяющий стандартный класс Activity(Активити)

//класс NotificationCloserActivity состоит из:

//констант:

//глобальную статическую строковую переменную ID_УВЕДОМЛЕНИЯ = "ID_УВЕДОМЛЕНИЯ"

// методов :

// закрытый метод типа  void  onCreate()  вызывается, чтобы приложение создало и отобразило  разметку активности NotificationCloserActivity
//    // Метод помечен как protected и сопровождается аннотацией @Override (переопределён из базового класса).
// . Если вы сделаете опечатку в имени метода, токомпилятор сможет предупредить вас, сообщив об отсутствии  такого метода у
// родительского класса Activity

//в  теле метода  onCreate() выполняются задачи:

//Управляющий_уведомлениями  получает системный сервис(по константе(СЕРВИС_УВЕДОМЛЕНИЯ)

//Управляющий_уведомлениями  отменяет выполнение задачи получения системного сервиса

//Выполнять:в Главной_Активности Остановить_Воспроизведение_Видео()

// если Главная_Aктивность  не запущена -  то  генерация исключения..


//открытый метод  Получить_Отклоненный_Интент типа Незавершенный_интент(Id уведомления,Контекст)

// создаем интент,связывающий Контекст_приложения с классом Закрывающий_Уведомления

//созданному  интенту устанавливаем  флаг ФЛАГ_НОВОЙ_ЗАДАЧИ_АКТИВНОСТИ или ФЛАГ_НОВОЙ_ЗАДАЧИ_АКТИВНОСТИ

//интент производит  передачу объекта с ключом "ID_УВЕДОМЛЕНИЯ" и значением "notificationId"

//Значение отклоненный_интент типа Незавершенный_интент  равно
// Отклоненный_интент.Получающий_Активность(по контексту,интент,Незавершенный_интент.с ФЛАГОМ_ТЕКУЩЕЙ_ОТМЕНЫ

//возвратить Отклоненный_интент


public class NotificationCloserActivity extends Activity {

    //глобальную статическую строковую переменную ID_УВЕДОМЛЕНИЯ = "ID_УВЕДОМЛЕНИЯ"

    public static final String NOTIFICATION_ID = "NOTIFICATION_ID";

    //   МЕТОД  onCreate()  АКТИВНОСТИ NotificationCloserActivity ДЛЯ ЕЕ ИНИЦИАЛИЗАЦИИ

    // метод onCreate() – он вызывается, когда //приложение создаёт и отображает разметку активности.
    // Метод помечен как protected и сопровождается аннотацией @Override (переопределён из базового класса). Аннотация
    // может пригодиться вам. Если вы сделаете опечатку в имени метода, токомпилятор сможет предупредить вас, сообщив об отсутствии
    // такого метода у родительского класса Activity.

    //Класс bundle служит для передачи данных простых типов между Активити.

    // Передача осуществляется через различные механизмы

    // (1. Просто ключ-значение
    // 2. Интерфейс Parcelable
    // 3. механизм Serizilable
    // 4. библиотека GSON От гугла.)

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        Log.i("CLOSED", "closing");

        //Управляющий_уведомлениями  получает системный сервис(по константе(СЕРВИС_УВЕДОМЛЕНИЯ)
        NotificationManager manager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);

        //Управляющий_уведомлениями  отменяет выполнение задачи получения системного сервиса

        //Управляющий_уведомлениями .Отменяет(Получение_интента().С_полученнными((ID_УВЕДОМЛЕНИЯ, -1))
        //
        // Определение намерения, запустившего активность с помощью метода getIntent()
        //При старте активности с помощью неявного намерения необходимо определить действие, которое следует выполнить,
        // и данные для этого действия.
        // Метод getIntent() активности позволяет получить объект намерения

        manager.cancel(getIntent().getIntExtra(NOTIFICATION_ID, -1));

        //блок try - catch (Exception e)

        //Выполнять:в Главной_Активности Остановить_Воспроизведение_Видео()
        try {
            MainActivity.pauseVideo();
        }

        // если Главная_Aктивность  не запущена -  то  генерация исключения..
        catch (Exception e)
        {
            // Aктивность  не запущена
        }
        finish(); // с тех пор метод как  finish() был вызван в методе onCreate(),метод  onDestroy() должен быть вызван немедленно
    }

    //открытый метод  Получить_Отклоненный_Интент типа Незавершенный_интент(Id уведомления,Контекст)

    public static PendingIntent getDismissIntent(int notificationId, Context context_Application)
    {
        // создаем интент,связывающий Контекст_приложения с классом Закрывающий_Уведомления

//Context – это объект, который предоставляет доступ к базовым функциям приложения: доступ к ресурсам, к файловой системе,
// вызов активности и т.д.Aктивность является подклассом Context

        Intent intent = new Intent(context_Application,NotificationCloserActivity.class);

        //созданному  интенту устанавливаем  флаг ФЛАГ_НОВОЙ_ЗАДАЧИ_АКТИВНОСТИ или ФЛАГ_НОВОЙ_ЗАДАЧИ_АКТИВНОСТИ

        //Изменить поведение объектов Intent можна с помощью указания флагов (методом setFlag()) перед вызовом метода startActivity(Intent)
        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);

        // передача объекта с  помощью интента с ключом "ID_УВЕДОМЛЕНИЯ" и значением "notificationId"

        //Для передачи данных применяется метод putExtra(), который в качестве значения позволяет передать
        // данные простейших типов - String, int, float, double, long, short, byte, char, массивы этих типов,
        // либо объект интерфейса Serializable.

        //   Чтобы получить отправленные данные при загрузке SecondActivity, можно воспользоваться методом get(), в который передается ключ объекта:
        //Bundle arguments = getIntent().getExtras();
        //String name = arguments.get("hello").toString();

        intent.putExtra(NOTIFICATION_ID, notificationId);

        //Значение отклоненный_интент типа Незавершенный_интент  равно Отклоненный_интент.Получающий_Активность(по контексту,интент,Незавершенный_интент.с ФЛАГОМ_ТЕКУЩЕЙ_ОТМЕНЫ
        PendingIntent dismissIntent = PendingIntent.getActivity(context_Application, 0, intent, PendingIntent.FLAG_CANCEL_CURRENT);

        //возвратить Отклоненный_интент
        return dismissIntent;
    }
}





